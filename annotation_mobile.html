<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Image Annotation Tool (Touch)</title>
  <style>
    :root { --bg:#0b0d10; --panel:#12161c; --text:#e7eef7; --muted:#9fb0c3; --accent:#4da3ff; --danger:#ff5d5d; }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
      padding-bottom: env(safe-area-inset-bottom);
    }
    header{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      position:sticky;
      top:0;
      z-index:10;
      background:var(--bg);
      padding-top: calc(12px + env(safe-area-inset-top));
    }
    header .group{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button, input[type="file"]{
      background:var(--panel); color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      border-radius:10px; padding:8px 10px; font-size:14px;
    }
    button{ cursor:pointer; }
    button.primary{ border-color:rgba(77,163,255,.45); box-shadow:0 0 0 1px rgba(77,163,255,.18) inset; }
    button.danger{ border-color:rgba(255,93,93,.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .hint{ color:var(--muted); font-size:13px; }
    main{ padding:16px; display:grid; grid-template-columns: 1fr 320px; gap:16px; }
    @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }

    .stage{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px; padding:12px; overflow:auto; min-height: 420px;
      -webkit-overflow-scrolling: touch;
    }
    .canvas-wrap{ position:relative; display:inline-block; user-select:none; touch-action:none; }
    canvas{ display:block; border-radius:12px; background:#0e1116; }
    .overlay{ position:absolute; inset:0; cursor: crosshair; touch-action:none; }
    .side{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
      display:flex; flex-direction:column; gap:12px;
      height: fit-content;
    }
    .card{
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:10px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row .grow{ flex:1 1 auto; }

    .toolbtn{
      width:44px; height:38px; padding:0;
      display:inline-flex; align-items:center; justify-content:center;
      font-size:18px; line-height:1;
      border-radius:12px;
    }
    .toolbtn.active{
      border-color: rgba(77,163,255,.65);
      box-shadow: 0 0 0 1px rgba(77,163,255,.22) inset;
    }
    .toolbtn .sub{
      font-size:11px; color:var(--muted); margin-left:4px; transform: translateY(1px);
    }

    .list{
      max-height: 400px; overflow:auto;
      display:flex; flex-direction:column; gap:8px;
      padding-right:4px;
    }
    .item{
      display:flex; gap:10px; align-items:flex-start;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:8px;
      background: rgba(0,0,0,.18);
      cursor:pointer;
    }
    .badge{
      font-size:14px; color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:2px 8px;
      white-space:nowrap;
      width:38px;
      text-align:center;
    }
    .item .meta{ min-width:0; flex:1; }
    .item .title{
      font-size:13px; line-height:1.25;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width:180px;
    }
    .item .controls{ display:flex; gap:6px; align-items:center; margin-top:6px; flex-wrap:wrap; }
    .font-adj{
      display:inline-flex; align-items:center; gap:0;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px; overflow:hidden;
      background: rgba(0,0,0,.25);
    }
    .font-adj button{
      width:22px; height:22px; padding:0;
      border:none; border-radius:0;
      background:transparent; color:var(--text);
      font-size:14px; line-height:1;
      cursor:pointer;
    }
    .font-adj button:hover{ background:rgba(255,255,255,.08); }
    .font-adj .val{
      min-width:28px; text-align:center;
      font-size:11px; color:var(--muted);
      padding:0 2px;
    }
    .color-sel{
      padding:2px 6px; font-size:11px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:6px;
      background:rgba(0,0,0,.25);
      color:var(--text);
      cursor:pointer;
    }
    .color-sel:focus{ outline:none; border-color:var(--accent); }

    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px; border:1px solid rgba(255,255,255,.14); border-bottom-width:2px;
      padding:1px 6px; border-radius:8px; color:var(--muted);
    }

    /* Text editor modal */
    .modal{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .modal.open{ display:flex; }
    .modal-card{
      width:min(720px, 100%);
      background: var(--panel);
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.45);
    }
    .modal-title{ font-weight:600; margin-bottom:10px; }
    textarea{
      width:100%;
      min-height:120px;
      resize:vertical;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      padding:10px;
      font-size:14px;
      line-height:1.35;
      outline:none;
    }
    .modal-actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:10px; }

    @media (max-width: 980px){
      header{ gap:10px; }
      button, input[type="file"]{ padding:10px 12px; font-size:15px; }
      .toolbtn{ width:52px; height:44px; font-size:20px; }
      .toolbtn .sub{ font-size:12px; }
      .hint{ font-size:14px; }
      main{ padding:12px; gap:12px; }
      .stage{ min-height: 320px; }
      .list{ max-height:260px; }
      .item{ padding:10px; }
      .badge{ width:44px; }
      textarea{ font-size:16px; }
    }
  </style>
</head>
<body>
<header>
  <div class="group">
    <input id="file" type="file" accept="image/*" />

    <div class="group" aria-label="tools">
      <button id="btnSingle" class="toolbtn active" title="Single-headed arrow + tail text">→<span class="sub">T</span></button>
      <button id="btnDouble" class="toolbtn" title="Double-headed arrow + center size text">↔<span class="sub">10</span></button>
      <button id="btnText" class="toolbtn" title="Text box only (no arrow)">T</button>
      <button id="btnSelect" class="toolbtn" title="Select / edit">⌖</button>
    </div>

    <button id="undo" title="Undo (Ctrl/Cmd+Z)">Undo</button>
    <button id="export" class="primary">Export</button>
  </div>

  <div class="hint">
    Touch: tap start → tap end → type text. Text only: tap once → type text.
    <span class="kbd">Del</span> delete selection, <span class="kbd">Ctrl/Cmd+Z</span> undo.
  </div>
</header>

<main>
  <section class="stage">
    <div class="canvas-wrap" id="wrap">
      <canvas id="c"></canvas>
      <div class="overlay" id="overlay" aria-label="interaction layer"></div>
    </div>
  </section>

  <aside class="side">
    <div class="card">
      <div class="row">
        <div class="grow">
          <div style="font-weight:600;">Tool state</div>
          <div class="hint" id="status">Upload an image to begin.</div>
        </div>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="editText">Edit text</button>
        <button id="delete" class="danger">Delete</button>
        <button id="clearAll" class="danger">Clear all</button>
      </div>
      <div class="hint" style="margin-top:8px;">
        Drag endpoints to adjust. Drag near the line to move the whole arrow.
      </div>
    </div>

    <div class="card">
      <div style="font-weight:600; margin-bottom:8px;">Annotations</div>
      <div class="list" id="list"></div>
    </div>
  </aside>
</main>

<!-- Text editor modal -->
<div class="modal" id="modal">
  <div class="modal-card">
    <div class="modal-title" id="modalTitle">Edit text</div>
    <textarea id="modalText" placeholder="Type annotation text..."></textarea>
    <div class="modal-actions">
      <button id="modalCancel">Cancel</button>
      <button id="modalOk" class="primary">OK</button>
    </div>
    <div class="hint" style="margin-top:10px;">
      Tip: line breaks are allowed. Text will be clamped inside the image on render/export.
      <span class="kbd">Ctrl/Cmd+Enter</span> to confirm.
    </div>
  </div>
</div>

<script>
(() => {
  const DEFAULT_COLOR = '#ff0000';
  const BLUE = '#3aa0ff';

  // Available colors for annotations
  const COLOR_OPTIONS = [
    { value: '#ff0000', label: 'Red' },
    { value: '#00cc00', label: 'Green' },
    { value: '#0088ff', label: 'Blue' },
    { value: '#ff8800', label: 'Orange' },
    { value: '#aa00ff', label: 'Purple' },
    { value: '#ffcc00', label: 'Yellow' },
    { value: '#00cccc', label: 'Cyan' },
    { value: '#ff0088', label: 'Pink' },
    { value: '#ffffff', label: 'White' },
    { value: '#000000', label: 'Black' },
  ];

  const DEFAULT_FONT_SIZE = 100; // percentage (100 = normal)
  const MIN_FONT_SIZE = 50;
  const MAX_FONT_SIZE = 200;
  const FONT_STEP = 10;

  const DEFAULT_LINE_WIDTH = 100; // percentage (100 = normal)
  const MIN_LINE_WIDTH = 25;
  const MAX_LINE_WIDTH = 200;
  const LINE_WIDTH_STEP = 25;

  const fileEl = document.getElementById('file');
  const overlay = document.getElementById('overlay');
  const canvas = document.getElementById('c');
  const wrap = document.getElementById('wrap');
  const statusEl = document.getElementById('status');
  const listEl = document.getElementById('list');
  const headerEl = document.querySelector('header');

  const undoEl = document.getElementById('undo');
  const exportEl = document.getElementById('export');
  const editTextEl = document.getElementById('editText');
  const deleteEl = document.getElementById('delete');
  const clearAllEl = document.getElementById('clearAll');

  const btnSingle = document.getElementById('btnSingle');
  const btnDouble = document.getElementById('btnDouble');
  const btnText = document.getElementById('btnText');
  const btnSelect = document.getElementById('btnSelect');

  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalText = document.getElementById('modalText');
  const modalCancel = document.getElementById('modalCancel');
  const modalOk = document.getElementById('modalOk');

  const ctx = canvas.getContext('2d');

  /** @type {HTMLImageElement|null} */
  let img = null;
  let originalFileName = 'image';

  /** @type {Array<Annotation>} */
  let anns = [];

  /** @type {Array<Array<Annotation>>} */
  let undoStack = [];

  let mode = 'single'; // 'single' | 'double' | 'text' | 'select'
  let placing = null;  // { type, start:{x,y}, cur:{x,y} }
  let selectedId = null;
  let drag = null;     // { kind:'move'|'p0'|'p1', id, startMouse, startAnn }
  let activePointerId = null;

  const mediaCoarse = window.matchMedia('(pointer: coarse)');
  let HANDLE_R = mediaCoarse.matches ? 12 : 7;
  let HIT_LINE_PX = mediaCoarse.matches ? 18 : 10;

  /** @typedef {{
   *  id: string,
   *  type: 'single'|'double'|'text',
   *  x0:number, y0:number, x1:number, y1:number,
   *  text:string,
   *  color:string,
   *  fontSize:number,
   *  lineWidth:number
   * }} Annotation
   */

  function updateInteractionSizing() {
    HANDLE_R = mediaCoarse.matches ? 12 : 7;
    HIT_LINE_PX = mediaCoarse.matches ? 18 : 10;
  }
  mediaCoarse.addEventListener('change', updateInteractionSizing);

  function uid() { return Math.random().toString(16).slice(2) + Date.now().toString(16); }
  function deepCopyAnns(a) { return a.map(o => ({...o})); }

  function pushUndo() {
    undoStack.push(deepCopyAnns(anns));
    if (undoStack.length > 50) undoStack.shift();
    updateUndoUI();
  }

  function doUndo() {
    if (!undoStack.length) return;
    anns = undoStack.pop();
    selectedId = null;
    placing = null;
    drag = null;
    updateUndoUI();
    render();
    refreshList();
    setStatus('Undid last action.');
  }

  function updateUndoUI() { undoEl.disabled = undoStack.length === 0; }
  function setStatus(msg) { statusEl.textContent = msg; }

  function getLayoutMetrics() {
    const narrow = window.matchMedia('(max-width: 980px)').matches;
    const headerHeight = headerEl ? headerEl.getBoundingClientRect().height : 120;
    const sidebarWidth = narrow ? 0 : 340;
    const padding = narrow ? 24 : 48;
    return { headerHeight, sidebarWidth, padding };
  }

  function fitCanvasToImage(image) {
    const { headerHeight, sidebarWidth, padding } = getLayoutMetrics();

    const availW = Math.max(320, window.innerWidth - sidebarWidth - padding);
    const availH = Math.max(260, window.innerHeight - headerHeight - padding);

    const maxW = 3200;
    const maxH = 3000;
    const maxPixels = 4 * 1000 * 1000; // 4 megapixels for smooth canvas ops

    let w = image.naturalWidth;
    let h = image.naturalHeight;

    let s = Math.min(1, availW / w, availH / h);

    s = Math.min(s, maxW / w, maxH / h);

    const pixels = (w * s) * (h * s);
    if (pixels > maxPixels) {
      s *= Math.sqrt(maxPixels / pixels);
    }

    const minDim = 300;
    const scaledMin = Math.min(w * s, h * s);
    if (scaledMin < minDim && Math.min(w, h) >= minDim) {
      s = Math.max(s, minDim / Math.min(w, h));
    }

    w = Math.round(w * s);
    h = Math.round(h * s);

    canvas.width = w;
    canvas.height = h;
    overlay.style.width = w + 'px';
    overlay.style.height = h + 'px';
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function dist2(ax, ay, bx, by) { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function pointToSegmentDistance(px, py, ax, ay, bx, by) {
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const ab2 = abx*abx + aby*aby;
    let t = ab2 ? (apx*abx + apy*aby) / ab2 : 0;
    t = clamp(t, 0, 1);
    const cx = ax + t*abx, cy = ay + t*aby;
    return Math.hypot(px - cx, py - cy);
  }

  function getPointerPos(evt) {
    const r = overlay.getBoundingClientRect();
    return { x: evt.clientX - r.left, y: evt.clientY - r.top };
  }

  function annotationById(id) { return anns.find(a => a.id === id) || null; }

  function pickAnnotation(pt) {
    const order = selectedId ? [annotationById(selectedId), ...anns.filter(a => a.id !== selectedId)] : [...anns];
    for (const a of order) {
      if (!a) continue;
      if (a.type === 'text') {
        if (Math.sqrt(dist2(pt.x, pt.y, a.x0, a.y0)) <= HANDLE_R + 15) return { id: a.id, kind:'move' };
        continue;
      }
      if (Math.sqrt(dist2(pt.x, pt.y, a.x0, a.y0)) <= HANDLE_R + 3) return { id: a.id, kind:'p0' };
      if (Math.sqrt(dist2(pt.x, pt.y, a.x1, a.y1)) <= HANDLE_R + 3) return { id: a.id, kind:'p1' };
    }
    for (let i = anns.length - 1; i >= 0; i--) {
      const a = anns[i];
      if (a.type === 'text') continue; // already handled above
      const d = pointToSegmentDistance(pt.x, pt.y, a.x0, a.y0, a.x1, a.y1);
      if (d <= HIT_LINE_PX) return { id: a.id, kind:'move' };
    }
    return null;
  }

  function measureFontPx(W, H) {
    const base = Math.round(Math.min(W, H) * 0.05);
    return clamp(base, 18, 140);
  }
  function measureLineWidth(W, H) {
    const lw = Math.round(Math.min(W, H) * 0.0055);
    return clamp(lw, 3, 24);
  }

  function wrapTextToWidth(ctx2, text, maxWidth, font) {
    const raw = (text ?? '').toString().replace(/\r\n/g, '\n');
    const paragraphs = raw.split('\n');

    ctx2.save();
    ctx2.font = font;

    const out = [];
    for (const para of paragraphs) {
      const words = para.trim().split(/\s+/).filter(Boolean);
      if (!words.length) { out.push(''); continue; }

      let line = words[0];
      for (let i = 1; i < words.length; i++) {
        const test = line + ' ' + words[i];
        if (ctx2.measureText(test).width <= maxWidth) line = test;
        else { out.push(line); line = words[i]; }
      }
      out.push(line);
    }

    const finalLines = [];
    for (const l of out) {
      if (ctx2.measureText(l).width <= maxWidth) { finalLines.push(l); continue; }
      let cur = '';
      for (const ch of l) {
        const test = cur + ch;
        if (ctx2.measureText(test).width <= maxWidth) cur = test;
        else { if (cur) finalLines.push(cur); cur = ch; }
      }
      if (cur) finalLines.push(cur);
    }

    ctx2.restore();
    return finalLines.slice(0, 10);
  }

  function drawArrowHead(ctx2, xTail, yTail, xTip, yTip, size) {
    const dx = xTip - xTail, dy = yTip - yTail;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;
    const px = -uy, py = ux;
    const s = size;

    const bx = xTip - ux * s;
    const by = yTip - uy * s;
    const c1x = bx + px * (s * 0.6);
    const c1y = by + py * (s * 0.6);
    const c2x = bx - px * (s * 0.6);
    const c2y = by - py * (s * 0.6);

    ctx2.beginPath();
    ctx2.moveTo(xTip, yTip);
    ctx2.lineTo(c1x, c1y);
    ctx2.lineTo(c2x, c2y);
    ctx2.closePath();
    ctx2.fill();
  }

  function measureTextBlock(ctx2, lines, fontPx, maxW) {
    ctx2.save();
    ctx2.font = `${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    const lineH = Math.round(fontPx * 1.22);
    let w = 0;
    for (const ln of lines) w = Math.max(w, ctx2.measureText(ln).width);
    w = Math.min(w, maxW);
    const h = lines.length * lineH;
    ctx2.restore();
    return { w, h, lineH };
  }

  function drawTextNoBox(ctx2, lines, centerX, centerY, fontPx, maxW, W, H, color) {
    const { w, h, lineH } = measureTextBlock(ctx2, lines, fontPx, maxW);

    const x0 = clamp(centerX - w/2, 2, W - w - 2);
    const y0 = clamp(centerY - h/2, 2, H - h - 2);

    ctx2.save();
    ctx2.font = `${fontPx}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx2.fillStyle = color || DEFAULT_COLOR;
    ctx2.textBaseline = 'top';
    for (let i = 0; i < lines.length; i++) {
      ctx2.fillText(lines[i], x0, y0 + i * lineH);
    }
    ctx2.restore();

    return { x0, y0, w, h };
  }

  function unitAndNormal(x0,y0,x1,y1) {
    const dx = x1 - x0, dy = y1 - y0;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;
    let nx = -uy, ny = ux;
    if (ny > 0) { nx = -nx; ny = -ny; }
    if (Math.abs(ny) < 0.15 && nx > 0) { nx = -nx; ny = -ny; }
    return { ux, uy, nx, ny, len };
  }

  function projectionRadius(tbW, tbH, ux, uy) {
    return Math.abs(ux) * (tbW / 2) + Math.abs(uy) * (tbH / 2);
  }

  function drawAnnotation(ctx2, a, selected, W, H, scale = 1) {
    const baseFontPx = measureFontPx(W / scale, H / scale) * scale;
    const fontScale = (a.fontSize || DEFAULT_FONT_SIZE) / 100;
    const fontPx = baseFontPx * fontScale;
    const baseLineW = measureLineWidth(W / scale, H / scale) * scale;
    const lineWidthScale = (a.lineWidth || DEFAULT_LINE_WIDTH) / 100;
    const lineW = baseLineW * lineWidthScale;
    const head = Math.max(14 * scale * lineWidthScale, Math.round(lineW * 5.5));

    const color = a.color || DEFAULT_COLOR;

    ctx2.save();
    ctx2.lineWidth = lineW;
    ctx2.strokeStyle = color;
    ctx2.fillStyle = color;

    if (a.type === 'text') {
      const maxW = Math.max(200, Math.round(W * 0.45));
      const lines = wrapTextToWidth(ctx2, a.text, maxW, `${fontPx}px ui-sans-serif`);
      drawTextNoBox(ctx2, lines, a.x0, a.y0, fontPx, maxW, W, H, color);

      if (selected) {
        ctx2.save();
        ctx2.fillStyle = BLUE;
        ctx2.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx2.lineWidth = 2;
        ctx2.beginPath();
        ctx2.arc(a.x0, a.y0, HANDLE_R, 0, Math.PI*2);
        ctx2.fill();
        ctx2.stroke();
        ctx2.restore();
      }

      ctx2.restore();
      return;
    }

    const adx = a.x1 - a.x0, ady = a.y1 - a.y0;
    const alen = Math.hypot(adx, ady) || 1;
    const aux = adx / alen, auy = ady / alen;

    let lx0 = a.x0, ly0 = a.y0, lx1 = a.x1, ly1 = a.y1;
    if (a.type === 'single') {
      lx1 = a.x1 - aux * head;
      ly1 = a.y1 - auy * head;
    } else {
      lx0 = a.x0 + aux * head;
      ly0 = a.y0 + auy * head;
      lx1 = a.x1 - aux * head;
      ly1 = a.y1 - auy * head;
    }
    ctx2.beginPath();
    ctx2.moveTo(lx0, ly0);
    ctx2.lineTo(lx1, ly1);
    ctx2.stroke();

    if (a.type === 'single') {
      drawArrowHead(ctx2, a.x0, a.y0, a.x1, a.y1, head);
    } else {
      drawArrowHead(ctx2, a.x0, a.y0, a.x1, a.y1, head);
      drawArrowHead(ctx2, a.x1, a.y1, a.x0, a.y0, head);
    }

    const { ux, uy, nx, ny } = unitAndNormal(a.x0,a.y0,a.x1,a.y1);
    const maxW = Math.max(200, Math.round(W * (a.type === 'single' ? (H > W ? 0.5 : 0.42) : 0.32)));
    const lines = wrapTextToWidth(ctx2, a.text, maxW, `${fontPx}px ui-sans-serif`);
    const tb = measureTextBlock(ctx2, lines, fontPx, maxW);
    const margin = Math.max(lineW * 2.0, fontPx * 0.4);

    let centerX, centerY;

    if (a.type === 'single') {
      const along = 0.5 * Math.min(tb.w / Math.abs(ux), tb.h / Math.abs(uy)) + margin;

      centerX = a.x0 - ux * along;
      centerY = a.y0 - uy * along;

      const borderPad = 2 + tb.h/2;
      if (centerX < borderPad || centerX > W - borderPad || centerY < borderPad || centerY > H - borderPad) {
        const nudge = Math.max(lineW * 3, fontPx * 0.35);
        centerX += nx * nudge;
        centerY += ny * nudge;
      }
    } else {
      const mx = (a.x0 + a.x1) / 2;
      const my = (a.y0 + a.y1) / 2;
      const gap = projectionRadius(tb.w, tb.h, uy, ux) + margin;
      centerX = mx + nx * gap;
      centerY = my + ny * gap;
    }

    drawTextNoBox(ctx2, lines, centerX, centerY, fontPx, maxW, W, H, color);

    if (selected) {
      ctx2.save();
      ctx2.fillStyle = BLUE;
      ctx2.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx2.lineWidth = 2;
      for (const p of [[a.x0,a.y0],[a.x1,a.y1]]) {
        ctx2.beginPath();
        ctx2.arc(p[0], p[1], HANDLE_R, 0, Math.PI*2);
        ctx2.fill();
        ctx2.stroke();
      }
      ctx2.restore();
    }

    ctx2.restore();
  }

  function render() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (img) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    else {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '16px ui-sans-serif, system-ui';
      ctx.fillText('Upload an image to start annotating.', 18, 28);
      ctx.restore();
      return;
    }

    for (const a of anns) drawAnnotation(ctx, a, a.id === selectedId, canvas.width, canvas.height);

    if (placing) {
      ctx.save();
      ctx.strokeStyle = DEFAULT_COLOR;
      ctx.lineWidth = measureLineWidth(canvas.width, canvas.height);
      ctx.setLineDash([10, 8]);
      ctx.beginPath();
      ctx.moveTo(placing.start.x, placing.start.y);
      ctx.lineTo(placing.cur.x, placing.cur.y);
      ctx.stroke();
      ctx.restore();
    }
  }

  function truncateText(text, maxLen = 25) {
    if (!text) return '(empty)';
    if (text.length <= maxLen) return text;
    return text.slice(0, maxLen - 1) + '…';
  }

  function refreshList() {
    listEl.innerHTML = '';
    if (!anns.length) {
      const empty = document.createElement('div');
      empty.className = 'hint';
      empty.textContent = 'No annotations yet.';
      listEl.appendChild(empty);
      return;
    }
    for (const a of anns.slice().reverse()) {
      const row = document.createElement('div');
      row.className = 'item';
      row.style.borderColor = (a.id === selectedId) ? 'rgba(77,163,255,.55)' : 'rgba(255,255,255,.10)';

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = a.type === 'text' ? 'T' : (a.type === 'single' ? '→' : '↔');
      badge.style.color = a.color || DEFAULT_COLOR;
      badge.style.borderColor = a.color || DEFAULT_COLOR;

      const meta = document.createElement('div');
      meta.className = 'meta';

      const t = document.createElement('div');
      t.className = 'title';
      t.textContent = truncateText(a.text);
      t.title = a.text || '(empty)'; // full text on hover
      meta.appendChild(t);

      const controls = document.createElement('div');
      controls.className = 'controls';

      const fontAdj = document.createElement('div');
      fontAdj.className = 'font-adj';

      const minusBtn = document.createElement('button');
      minusBtn.textContent = '−';
      minusBtn.title = 'Decrease font size';
      minusBtn.onclick = (e) => {
        e.stopPropagation();
        if ((a.fontSize || DEFAULT_FONT_SIZE) > MIN_FONT_SIZE) {
          pushUndo();
          a.fontSize = (a.fontSize || DEFAULT_FONT_SIZE) - FONT_STEP;
          render();
          refreshList();
        }
      };

      const fontVal = document.createElement('span');
      fontVal.className = 'val';
      fontVal.textContent = 'T ' + (a.fontSize || DEFAULT_FONT_SIZE) + '%';

      const plusBtn = document.createElement('button');
      plusBtn.textContent = '+';
      plusBtn.title = 'Increase font size';
      plusBtn.onclick = (e) => {
        e.stopPropagation();
        if ((a.fontSize || DEFAULT_FONT_SIZE) < MAX_FONT_SIZE) {
          pushUndo();
          a.fontSize = (a.fontSize || DEFAULT_FONT_SIZE) + FONT_STEP;
          render();
          refreshList();
        }
      };

      fontAdj.appendChild(minusBtn);
      fontAdj.appendChild(fontVal);
      fontAdj.appendChild(plusBtn);

      const colorSel = document.createElement('select');
      colorSel.className = 'color-sel';
      colorSel.title = 'Change color';
      for (const opt of COLOR_OPTIONS) {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        option.style.color = opt.value;
        if ((a.color || DEFAULT_COLOR) === opt.value) option.selected = true;
        colorSel.appendChild(option);
      }
      colorSel.onchange = (e) => {
        e.stopPropagation();
        pushUndo();
        a.color = colorSel.value;
        render();
        refreshList();
      };
      colorSel.onclick = (e) => e.stopPropagation();

      controls.appendChild(fontAdj);
      controls.appendChild(colorSel);

      if (a.type !== 'text') {
        const lineAdj = document.createElement('div');
        lineAdj.className = 'font-adj';
        lineAdj.title = 'Line width';

        const lineMinusBtn = document.createElement('button');
        lineMinusBtn.textContent = '−';
        lineMinusBtn.title = 'Decrease line width';
        lineMinusBtn.onclick = (e) => {
          e.stopPropagation();
          if ((a.lineWidth || DEFAULT_LINE_WIDTH) > MIN_LINE_WIDTH) {
            pushUndo();
            a.lineWidth = (a.lineWidth || DEFAULT_LINE_WIDTH) - LINE_WIDTH_STEP;
            render();
            refreshList();
          }
        };

        const lineVal = document.createElement('span');
        lineVal.className = 'val';
        lineVal.textContent = '↔ ' + (a.lineWidth || DEFAULT_LINE_WIDTH) + '%';

        const linePlusBtn = document.createElement('button');
        linePlusBtn.textContent = '+';
        linePlusBtn.title = 'Increase line width';
        linePlusBtn.onclick = (e) => {
          e.stopPropagation();
          if ((a.lineWidth || DEFAULT_LINE_WIDTH) < MAX_LINE_WIDTH) {
            pushUndo();
            a.lineWidth = (a.lineWidth || DEFAULT_LINE_WIDTH) + LINE_WIDTH_STEP;
            render();
            refreshList();
          }
        };

        lineAdj.appendChild(lineMinusBtn);
        lineAdj.appendChild(lineVal);
        lineAdj.appendChild(linePlusBtn);
        controls.appendChild(lineAdj);
      }

      meta.appendChild(controls);

      row.appendChild(badge);
      row.appendChild(meta);

      row.onclick = () => {
        selectedId = a.id;
        setMode('select');
        render();
        refreshList();
        setStatus('Selected annotation.');
      };

      listEl.appendChild(row);
    }
  }

  function ensureCanvasReady() {
    if (!img) { setStatus('Upload an image first.'); return false; }
    return true;
  }

  function setMode(next) {
    mode = next;
    placing = null;
    drag = null;
    btnSingle.classList.toggle('active', mode === 'single');
    btnDouble.classList.toggle('active', mode === 'double');
    btnText.classList.toggle('active', mode === 'text');
    btnSelect.classList.toggle('active', mode === 'select');

    if (mode !== 'select') selectedId = null;

    if (mode === 'select') setStatus('Select/edit mode: tap an annotation, drag to move.');
    else if (mode === 'text') setStatus('Text mode: tap to place a text box.');
    else setStatus('Add mode: tap start then end.');
    render(); refreshList();
  }

  btnSingle.onclick = () => setMode('single');
  btnDouble.onclick = () => setMode('double');
  btnText.onclick = () => setMode('text');
  btnSelect.onclick = () => setMode('select');

  // --- Textarea editor modal ---
  let modalResolve = null;

  function openTextEditor({ title, initial }) {
    modalTitle.textContent = title;
    modalText.value = initial ?? '';
    modal.classList.add('open');
    modalText.focus();
    modalText.selectionStart = modalText.value.length;
    modalText.selectionEnd = modalText.value.length;
    return new Promise((resolve) => { modalResolve = resolve; });
  }

  function closeTextEditor(result) {
    modal.classList.remove('open');
    const r = modalResolve;
    modalResolve = null;
    if (r) r(result);
  }

  modalCancel.onclick = () => closeTextEditor(null);
  modalOk.onclick = () => closeTextEditor(modalText.value);
  modal.addEventListener('mousedown', (e) => {
    if (e.target === modal) closeTextEditor(null);
  });
  window.addEventListener('keydown', (e) => {
    if (!modal.classList.contains('open')) return;
    if (e.key === 'Escape') { e.preventDefault(); closeTextEditor(null); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); closeTextEditor(modalText.value); }
  });

  // Upload
  fileEl.addEventListener('change', async () => {
    const f = fileEl.files && fileEl.files[0];
    if (!f) return;

    const nameParts = f.name.split('.');
    if (nameParts.length > 1) nameParts.pop();
    originalFileName = nameParts.join('.') || 'image';

    const url = URL.createObjectURL(f);
    const image = new Image();
    image.onload = () => {
      img = image;
      fitCanvasToImage(image);
      wrap.style.width = canvas.width + 'px';
      wrap.style.height = canvas.height + 'px';
      anns = [];
      undoStack = [];
      placing = null;
      selectedId = null;
      updateUndoUI();
      refreshList();
      render();
      setStatus('Image loaded. Choose an arrow tool and tap to start/end.');
      URL.revokeObjectURL(url);
    };
    image.src = url;
  });

  // Drag undo: push once at drag start
  let dragUndoPushed = false;
  function pushUndoOncePerDrag() {
    if (!drag || dragUndoPushed) return;
    pushUndo();
    dragUndoPushed = true;
  }
  overlay.addEventListener('pointerdown', () => { dragUndoPushed = false; });

  function addAnnotation(type, start, end, text) {
    const a = {
      id: uid(), type,
      x0:start.x, y0:start.y, x1:end.x, y1:end.y,
      text: (text ?? '').toString().trim(),
      color: DEFAULT_COLOR,
      fontSize: DEFAULT_FONT_SIZE,
      lineWidth: DEFAULT_LINE_WIDTH
    };
    anns.push(a);
    selectedId = a.id;
    refreshList();
    render();
  }

  function addTextAnnotation(pos, text) {
    const a = {
      id: uid(), type: 'text',
      x0: pos.x, y0: pos.y, x1: pos.x, y1: pos.y,
      text: (text ?? '').toString().trim(),
      color: DEFAULT_COLOR,
      fontSize: DEFAULT_FONT_SIZE,
      lineWidth: DEFAULT_LINE_WIDTH
    };
    anns.push(a);
    selectedId = a.id;
    refreshList();
    render();
  }

  // Pointer interactions (mouse + touch)
  overlay.addEventListener('pointerdown', (evt) => {
    if (!ensureCanvasReady()) return;
    if (activePointerId !== null && activePointerId !== evt.pointerId) return;
    activePointerId = evt.pointerId;
    overlay.setPointerCapture(evt.pointerId);
    if (evt.pointerType === 'touch') evt.preventDefault();

    const pt = getPointerPos(evt);

    if (mode === 'select') {
      const hit = pickAnnotation(pt);
      if (!hit) { selectedId = null; render(); refreshList(); return; }
      selectedId = hit.id;
      const a = annotationById(hit.id);
      drag = { kind: hit.kind, id: hit.id, startMouse: pt, startAnn: {...a} };
      render(); refreshList();
      return;
    }

    if (mode === 'text') {
      (async () => {
        const text = await openTextEditor({ title: 'Enter text', initial: '' });
        if (text === null) { render(); setStatus('Cancelled.'); return; }
        pushUndo();
        addTextAnnotation(pt, text);
        setMode('select');
        setStatus('Text added. Now in Select mode.');
      })();
      return;
    }

    const type = mode === 'double' ? 'double' : 'single';
    if (!placing) {
      placing = { type, start: pt, cur: pt };
      selectedId = null;
      render();
      setStatus('Now tap the end point.');
    } else {
      const start = placing.start;
      const end = pt;
      placing = null;

      if (Math.hypot(end.x - start.x, end.y - start.y) < 6) {
        render();
        setStatus('Arrow too short; try again.');
        return;
      }

      const title = (type === 'double')
        ? 'Enter size text (e.g., "10 in")'
        : 'Enter description text';

      (async () => {
        const text = await openTextEditor({ title, initial: '' });
        if (text === null) { render(); setStatus('Cancelled.'); return; }
        pushUndo();
        addAnnotation(type, start, end, text);

        setMode('select');
        setStatus('Added. Now in Select mode.');
      })();
    }
  });

  overlay.addEventListener('pointermove', (evt) => {
    if (!img) return;
    if (activePointerId !== null && evt.pointerId !== activePointerId) return;
    const pt = getPointerPos(evt);

    if (placing) {
      placing.cur = pt;
      render();
      return;
    }

    if (drag) {
      const a = annotationById(drag.id);
      if (!a) return;

      const dx = pt.x - drag.startMouse.x;
      const dy = pt.y - drag.startMouse.y;
      const base = drag.startAnn;

      pushUndoOncePerDrag();

      if (a.type === 'text') {
        a.x0 = clamp(base.x0 + dx, 0, canvas.width);
        a.y0 = clamp(base.y0 + dy, 0, canvas.height);
        a.x1 = a.x0;
        a.y1 = a.y0;
      } else if (drag.kind === 'move') {
        a.x0 = clamp(base.x0 + dx, 0, canvas.width);
        a.y0 = clamp(base.y0 + dy, 0, canvas.height);
        a.x1 = clamp(base.x1 + dx, 0, canvas.width);
        a.y1 = clamp(base.y1 + dy, 0, canvas.height);
      } else if (drag.kind === 'p0') {
        a.x0 = clamp(base.x0 + dx, 0, canvas.width);
        a.y0 = clamp(base.y0 + dy, 0, canvas.height);
      } else if (drag.kind === 'p1') {
        a.x1 = clamp(base.x1 + dx, 0, canvas.width);
        a.y1 = clamp(base.y1 + dy, 0, canvas.height);
      }
      render();
      refreshList();
    } else if (mode === 'select' && evt.pointerType !== 'touch') {
      const hit = pickAnnotation(pt);
      overlay.style.cursor = hit ? (hit.kind === 'move' ? 'move' : 'pointer') : 'default';
    } else if (evt.pointerType !== 'touch') {
      overlay.style.cursor = 'crosshair';
    }
  });

  function endPointerDrag(evt) {
    if (activePointerId !== null && evt.pointerId !== activePointerId) return;
    if (activePointerId !== null) {
      overlay.releasePointerCapture(activePointerId);
      activePointerId = null;
    }
    if (drag) {
      drag = null;
      render();
      setStatus('Edited annotation.');
    }
  }

  overlay.addEventListener('pointerup', endPointerDrag);
  overlay.addEventListener('pointercancel', endPointerDrag);

  overlay.addEventListener('pointerleave', (evt) => {
    if (placing) return;
    if (drag) { drag = null; render(); }
    if (evt.pointerType !== 'touch') overlay.style.cursor = 'default';
  });

  overlay.addEventListener('dblclick', async (evt) => {
    if (!ensureCanvasReady()) return;
    const pt = getPointerPos(evt);
    const hit = pickAnnotation(pt);
    if (!hit) return;

    selectedId = hit.id;
    const a = annotationById(hit.id);
    if (!a) return;

    let title;
    if (a.type === 'double') title = 'Edit size text (e.g., "10 in")';
    else if (a.type === 'text') title = 'Edit text';
    else title = 'Edit description text';

    const next = await openTextEditor({ title, initial: a.text });
    if (next === null) return;

    pushUndo();
    a.text = next.toString();
    render(); refreshList();
    setStatus('Text updated.');
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (modal.classList.contains('open')) return;

    const z = (e.key || '').toLowerCase() === 'z';
    const isUndo = (z && (e.ctrlKey || e.metaKey) && !e.shiftKey);
    if (isUndo) { e.preventDefault(); doUndo(); }

    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedId) {
      e.preventDefault();
      deleteSelected();
    }

    if (e.key === 'Escape') {
      placing = null; drag = null;
      render();
      setStatus('Cancelled current action.');
    }
  });

  // Buttons
  undoEl.addEventListener('click', doUndo);

  function deleteSelected() {
    if (!selectedId) return;
    pushUndo();
    anns = anns.filter(a => a.id !== selectedId);
    selectedId = null;
    render(); refreshList();
    setStatus('Deleted annotation.');
  }
  deleteEl.addEventListener('click', deleteSelected);

  editTextEl.addEventListener('click', async () => {
    if (!selectedId) { setStatus('Select an annotation first.'); return; }
    const a = annotationById(selectedId);
    if (!a) return;

    let title;
    if (a.type === 'double') title = 'Edit size text (e.g., "10 in")';
    else if (a.type === 'text') title = 'Edit text';
    else title = 'Edit description text';

    const next = await openTextEditor({ title, initial: a.text });
    if (next === null) return;

    pushUndo();
    a.text = next.toString();
    render(); refreshList();
    setStatus('Text updated.');
  });

  clearAllEl.addEventListener('click', () => {
    if (!img || !anns.length) return;
    const ok = window.confirm('Clear all annotations?');
    if (!ok) return;
    pushUndo();
    anns = [];
    selectedId = null;
    render(); refreshList();
    setStatus('Cleared all annotations.');
  });

  exportEl.addEventListener('click', () => {
    if (!img) { setStatus('Upload an image first.'); return; }

    const out = document.createElement('canvas');
    out.width = img.naturalWidth;
    out.height = img.naturalHeight;
    const octx = out.getContext('2d');

    octx.drawImage(img, 0, 0, out.width, out.height);

    const sx = out.width / canvas.width;
    const sy = out.height / canvas.height;
    const scale = (sx + sy) / 2;

    for (const a of anns) {
      const aa = {
        ...a,
        x0: a.x0 * sx, y0: a.y0 * sy,
        x1: a.x1 * sx, y1: a.y1 * sy
      };
      drawAnnotation(octx, aa, false, out.width, out.height, scale);
    }

    const link = document.createElement('a');
    link.download = `${originalFileName}_annotated.png`;
    link.href = out.toDataURL('image/png');
    document.body.appendChild(link);
    link.click();
    link.remove();

    setStatus('PNG exported.');
  });

  // Init
  canvas.width = 1200; canvas.height = 700;
  overlay.style.width = canvas.width + 'px';
  overlay.style.height = canvas.height + 'px';
  wrap.style.width = canvas.width + 'px';
  wrap.style.height = canvas.height + 'px';
  updateUndoUI();
  refreshList();
  render();
  setMode('single');

})();
</script>
</body>
</html>
